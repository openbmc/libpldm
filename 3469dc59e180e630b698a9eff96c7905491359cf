{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a5858771_c8c04619",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 26
      },
      "lineNbr": 0,
      "author": {
        "id": 1002522
      },
      "writtenOn": "2025-08-27T02:16:43Z",
      "side": 1,
      "message": "This looks good to me.",
      "revId": "3469dc59e180e630b698a9eff96c7905491359cf",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "254859a1_11b0071b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 26
      },
      "lineNbr": 0,
      "author": {
        "id": 1002522
      },
      "writtenOn": "2025-08-27T02:54:08Z",
      "side": 1,
      "message": "Mark as resolved.",
      "parentUuid": "a5858771_c8c04619",
      "revId": "3469dc59e180e630b698a9eff96c7905491359cf",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f7533d14_3ce66658",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 26
      },
      "lineNbr": 0,
      "author": {
        "id": 1002135
      },
      "writtenOn": "2025-08-27T03:00:04Z",
      "side": 1,
      "message": "LGTM, I\u0027m looking forward to apply this to many utilities.",
      "revId": "3469dc59e180e630b698a9eff96c7905491359cf",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c6af334_8bf70193",
        "filename": "include/libpldm/bindings/cpp/types.hpp",
        "patchSetId": 26
      },
      "lineNbr": 76,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-09-05T01:48:51Z",
      "side": 1,
      "message": "Does this not give us the same problems, but with the vtable, wrt extending the class?",
      "revId": "3469dc59e180e630b698a9eff96c7905491359cf",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2083734c_d6044bb7",
        "filename": "include/libpldm/bindings/cpp/types.hpp",
        "patchSetId": 26
      },
      "lineNbr": 76,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-05T12:13:12Z",
      "side": 1,
      "message": "looked into\n\nhttps://isocpp.org/wiki/faq/virtual-functions#dyn-binding\n\nand to me it looks like the non-virtual member functions have static dispatch and which function to call is resolved at compile-time.\n\nI am not using any virtual functions here, so i assume we will not get this issue.\n\nMade a small example \n```\n\nstruct A {\n    void foo() {}\n};\n\nstruct B {\n    virtual void foo() {}\n};\n\nclass C {\n\tpublic:\n\tint x;\n\tvoid cfoo(){\n\t\tx++;\n\t}\n};\n\nclass CDerived : public C {\n\tpublic:\n\tvoid cfoo() {\n\t\tx--;\n\t}\n};\n\nint main() {\n    A a;\n    B b;\n    C c;\n    CDerived cderived;\n\n    c.cfoo();\n    cderived.cfoo();\n}\n```\n\nand when using `g++ -fdump-lang-class vtable.cpp`\nit does generate some file\n```\nClass A\n   size\u003d1 align\u003d1\n   base size\u003d0 base align\u003d1\nA (0x0x7f3522dd5000) 0 empty\n\nVtable for B\nB::_ZTV1B: 3 entries\n0     (int (*)(...))0\n8     (int (*)(...))(\u0026 _ZTI1B)\n16    (int (*)(...))B::foo\n\nClass B\n   size\u003d8 align\u003d8\n   base size\u003d8 base align\u003d8\nB (0x0x7f3522dd5060) 0 nearly-empty\n    vptr\u003d((\u0026 B::_ZTV1B) + 16)\n\nClass C\n   size\u003d4 align\u003d4\n   base size\u003d4 base align\u003d4\nC (0x0x7f3522dd5180) 0\n\nClass CDerived\n   size\u003d4 align\u003d4\n   base size\u003d4 base align\u003d4\nCDerived (0x0x7f3522c0e478) 0\nC (0x0x7f3522dd51e0) 0\n```\n\nwhere B has a vtable and vptr, but the others do not.\n\nAlso added the dump flag when tests are built, so we have that available for inspection but it does not cause build time overhead for regular usage.\n\n```\n 8375 Class pldm::fw_update::ComponentImageInfoPrivate\n 8376    size\u003d72 align\u003d8\n 8377    base size\u003d72 base align\u003d8\n 8378 pldm::fw_update::ComponentImageInfoPrivate (0x0x7f3877e30780) 0\n\n 8547 Class pldm::fw_update::FirmwareDeviceIDRecordPrivate\n 8548    size\u003d136 align\u003d8\n 8549    base size\u003d136 base align\u003d8\n 8550 pldm::fw_update::FirmwareDeviceIDRecordPrivate (0x0x7f3877e30840) 0\n\n 8686 Class pldm::fw_update::PackagePrivate\n 8687    size\u003d48 align\u003d8\n 8688    base size\u003d48 base align\u003d8\n 8689 pldm::fw_update::PackagePrivate (0x0x7f3877fce900) 0\n\n 7098 Class pldm::fw_update::DescriptorData\n 7099    size\u003d8 align\u003d8\n 7100    base size\u003d8 base align\u003d8\n 7101 pldm::fw_update::DescriptorData (0x0x7f387893ef00) 0\n\n 7404 Class pldm::fw_update::ComponentImageInfo\n 7405    size\u003d8 align\u003d8\n 7406    base size\u003d8 base align\u003d8\n 7407 pldm::fw_update::ComponentImageInfo (0x0x7f387876b7e0) 0\n\n 7710 Class pldm::fw_update::FirmwareDeviceIDRecord\n 7711    size\u003d8 align\u003d8\n 7712    base size\u003d8 base align\u003d8\n 7713 pldm::fw_update::FirmwareDeviceIDRecord (0x0x7f38784e2540) 0\n\n 8016 Class pldm::fw_update::Package\n 8017    size\u003d8 align\u003d8\n 8018    base size\u003d8 base align\u003d8\n 8019 pldm::fw_update::Package (0x0x7f38782427e0) 0\n\n 8166 Class pldm::fw_update::PackageParserError\n 8167    size\u003d40 align\u003d8\n 8168    base size\u003d40 base align\u003d8\n 8169 pldm::fw_update::PackageParserError (0x0x7f38783c4ba0) 0\n\n 8171 Class pldm::fw_update::PackageParser\n 8172    size\u003d1 align\u003d1\n 8173    base size\u003d0 base align\u003d1\n 8174 pldm::fw_update::PackageParser (0x0x7f387815f3c0) 0 empty\n\n 8364 Class pldm::fw_update::DescriptorDataPrivate\n 8365    size\u003d64 align\u003d8\n 8366    base size\u003d64 base align\u003d8\n 8367 pldm::fw_update::DescriptorDataPrivate (0x0x7f387815f420) 0\n```\n\nBased on the dump extract i assume that our public classes (except `PackageParserError`) always have a size of 8 bytes to store the unique pointer to the private struct.\n\nSo the private structs can then be changed in size and layout without effects on ABI.\n\nI might go for D-pointer on `PackageParserError` as well, still considering.",
      "parentUuid": "5c6af334_8bf70193",
      "revId": "3469dc59e180e630b698a9eff96c7905491359cf",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ac01375_0239541d",
        "filename": "include/libpldm/bindings/cpp/types.hpp",
        "patchSetId": 26
      },
      "lineNbr": 76,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-09-09T02:42:36Z",
      "side": 1,
      "message": "Thanks for identifying my error there, and the in-depth discussion.\n\nSo rather, I think we would fail to dynamically link across a library downgrade, where the earlier library version doesn\u0027t export one of the static dispatch symbols referenced?\n\nIf that\u0027s the failure mode, is it the one we want?\n\nFor the C API we won\u0027t get a failure to link but will receive a runtime error due to the unrecognised pin.\n\nSeparately, and more broadly, I feel the approach is a bit duplicative and do wonder if there\u0027s an approach that\u0027s less tedious.\n\nPerhaps there are ideas to steal from here:\n\nhttps://github.com/lotem/mighty_struct?tab\u003dreadme-ov-file\n\nOtherwise, I\u0027m wondering if we could take a similar tack to the C APIs and have the caller pass in a reference to the container (e.g. `std::vec\u003cT\u003e`) where the binding should place the constructed objects. From there, we need to understand the behaviour of e.g. `std::vec\u003cT\u003e` across the library interface where the application and the library have differing ideas of `sizeof(T)`, how that interacts with e.g. `emplace_back()`, whether we have problems of partial construction or otherwise hit sources of undefined behaviour.",
      "parentUuid": "2083734c_d6044bb7",
      "revId": "3469dc59e180e630b698a9eff96c7905491359cf",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d5bef84_72a8b63c",
        "filename": "include/libpldm/bindings/cpp/types.hpp",
        "patchSetId": 26
      },
      "lineNbr": 76,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-09T11:49:31Z",
      "side": 1,
      "message": "\u003e So rather, I think we would fail to dynamically link across a library downgrade, where the earlier library version doesn\u0027t export one of the static dispatch symbols referenced?\n\nYes, i would expect linking failure\n\n\u003e If that\u0027s the failure mode, is it the one we want?\n\nThat\u0027s normal for libraries, right? If you depend on newly introduced API functions, then the application will not link against older library versions anymore.\n\n\u003e For the C API we won\u0027t get a failure to link but will receive a runtime error due to the unrecognised pin.\n\nI\u0027m not convinced. `libpldm` also adds new functions to the API surface, right?\n\n```\n## [0.13.0] 2025-06-15\n\n### Added\n\n- utils: Introduce `pldm_edac_crc32()`\n- utils: Introduce `pldm_edac_crc8()`\n- pdr: Add pldm_pdr_delete_by_effecter_id() API \n- platform: Add encode req for GetPDRRepositoryInfo\n- platform: Add encode req \u0026 decode resp for GetEventReceiver\n- pdr: Add pldm_pdr_delete_by_sensor_id() API \n- pdr: Add pldm_entity_association_tree_delete_node() API \n- base: Add decode_set_tid_req() API \n```\n\nIf i were to use the newly introduced function (libpldm `v0.13.0`)\n```\nint pldm_pdr_delete_by_sensor_id(pldm_pdr *repo, uint16_t sensor_id,\n                                bool is_remote, uint32_t *record_handle);\n```\n\nthen i would get linking error if i downgraded to (libpldm `v0.12.0`), right?\n\nThis kind of stability against library downgrade is relevant for callers wanting to be compatible with a range of libpldm versions.\n\nIt should be possible to achieve this with `libpldm`/`libpldmplus` by having a build matrix which compiles and links the application against a range of `libpldm`/`libpldmplus` versions.\n\nThen only symbols available in all of those versions can be used.\n\n\u003e Separately, and more broadly, I feel the approach is a bit duplicative and do wonder if there\u0027s an approach that\u0027s less tedious.\n\nIt\u0027s fairly easy to add struct fields with the proposed solution.\n\nWhere is the \u0027tedious\u0027 located, is it with the caller or the implementer of proposed solution? Is there some workflow which would be time-consuming to do with this API? Can you kindly go into detail here.\n\n\n\u003e Perhaps there are ideas to steal from here:\nhttps://github.com/lotem/mighty_struct?tab\u003dreadme-ov-file\n\nThat repo has 2 stars and is unmaintained for 11 years. Meanwhile Qt and KDE achieve the long-term stable ABI. So i would tend to go with their approach and only modernize it slightly by use of `std::unique_ptr` instead of inventing my own solution.\n\nIt looks to me like `libgpiodcxx` is also going with a smart pointer to a private struct for ABI stability.\n\nhttps://github.com/brgl/libgpiod/blob/4db87075549ebe3fa6d4d381186e30097f327fc7/bindings/cxx/gpiodcxx/chip.hpp#L156\n\nhttps://github.com/brgl/libgpiod/blob/4db87075549ebe3fa6d4d381186e30097f327fc7/bindings/cxx/chip.cpp#L139\n\nThen each public class has a private struct for member variables https://github.com/brgl/libgpiod/blob/4db87075549ebe3fa6d4d381186e30097f327fc7/bindings/cxx/internal.hpp#L92\n\n\n\u003e Otherwise, I\u0027m wondering if we could take a similar tack to the C APIs and have the caller pass in a reference to the container (e.g. std::vec\u003cT\u003e) where the binding should place the constructed objects.\n\nI like the high level API how it\u0027s currently defined. Pass in a pldm fw update package, get a smart pointer to the parsed package, if successful. \n\nIs there any problem with the high level API or any drawback why we would need something different?\n\nI agree there is a bunch of copying involved on various API functions and we can go over those in detail if you want a less overhead. I did not put too much effort there in the optimization since we are still in the API design stage.",
      "parentUuid": "8ac01375_0239541d",
      "revId": "3469dc59e180e630b698a9eff96c7905491359cf",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}