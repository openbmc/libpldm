{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "88470612_5097a62d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 1000224
      },
      "writtenOn": "2023-02-14T04:39:05Z",
      "side": 1,
      "message": "Patchset 16 is just reordering functions in the header and source file to be in the same order.",
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "93447550_d1637c6e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-14T05:19:47Z",
      "side": 1,
      "message": "A few remaining nitpicks :)",
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a0a54428_cbccb803",
        "filename": "include/libpldm/requester/pldm.h",
        "patchSetId": 16
      },
      "lineNbr": 212,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-14T05:19:47Z",
      "side": 1,
      "message": "Where does this instance ID come from? There\u0027s no provision in `pldm_requester_send_msg()` to provide it or for it to be returned. Is that something we need to consider?",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 212,
        "endChar": 18
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ced80351_43a2ffa4",
        "filename": "include/libpldm/requester/pldm.h",
        "patchSetId": 16
      },
      "lineNbr": 212,
      "author": {
        "id": 1000224
      },
      "writtenOn": "2023-02-14T07:36:56Z",
      "side": 1,
      "message": "It\u0027s in the PLDM header of the PLDM messages. So the caller is responsible for making sure something sensible is in the header of the msg given to `pldm_requester_send_msg` and passed in here. Do you think this needs to be clearer?",
      "parentUuid": "a0a54428_cbccb803",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 212,
        "endChar": 18
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22195980_89309111",
        "filename": "include/libpldm/requester/pldm.h",
        "patchSetId": 16
      },
      "lineNbr": 212,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-15T00:54:10Z",
      "side": 1,
      "message": "\u003e Do you think this needs to be clearer?\n\nI suspect we need to change it.\n\nLooking forward, I expect we\u0027re going to have to implement PLDM instance ID tagging in the kernel via specifying the `protocol` parameter to `socket(2)`. This means when we encode the message we will not know the ultimate value for the instance ID field until the message is sent via `sendto(2)`. As such, we need a way for the API to pass the value back out.\n\nI suspect what we should do is change the prototype of `pldm_requester_send_msg(...)` to:\n\n```\npldm_requester_rc_t pldm_requester_send_msg(struct pldm_requester *ctx,\n\t\t\t\t\t    pldm_tid_t tid,\n\t\t\t\t\t    uint8_t *instance_id,\n\t\t\t\t\t    const void *pldm_req_msg,\n\t\t\t\t\t    size_t req_msg_len)\n```\n\n`instance_id` is an `out` parameter only, not in. `instance_id` must not be `NULL`. if `instance_id` is `NULL` then we can return `PLDM_REQUESTER_INVALID_SETUP`. If the call is successful then the value pointed to by `instance_id` is the value of the instance ID the message was sent with.\n\nWith this definition we can maintain the current behaviour of externally requesting an instance ID from pldmd prior to encoding the message. For the implementation of `pldm_requester_send_msg()` we simply extract the encoded instance ID from the message and assign the value to `*instance_id`.\n\nWhen/if we move instance ID allocation into the kernel via `socket()`\u0027s `protocol` parameter we use the metadata returned by `sendto()` to populate `*instance_id`.\n\nThis feels like the API with the fewest sharp edges: We can continue to use `uint8_t` as the fundamental type for `*instance_id` as we don\u0027t need out-of-bounds values like `-1` to indicate a different behaviour, we don\u0027t need a `flags` parameter to control alternative behaviours, and `instance_id` never needs to be `NULL`.",
      "parentUuid": "ced80351_43a2ffa4",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 212,
        "endChar": 18
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee25aec1_5655a990",
        "filename": "include/libpldm/requester/pldm.h",
        "patchSetId": 16
      },
      "lineNbr": 212,
      "author": {
        "id": 1000005
      },
      "writtenOn": "2023-02-15T06:29:19Z",
      "side": 1,
      "message": "Why do we need to have PLDM instance ID tagging in the kernel? How about instance id expiration? will that be handled also by the kernel. \n\nI think we will need more clarity on all the aspects of the PLDM requester behavior (what is handled in the userspace vs kernel). Instance ID management is currently done in the userspace. https://github.com/openbmc/pldm/blob/master/requester/handler.hpp\n\nSeeing the scope of the changes in the patch, it seems we are missing on a design document.",
      "parentUuid": "22195980_89309111",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 212,
        "endChar": 18
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "90d4fd19_abd20891",
        "filename": "include/libpldm/requester/pldm.h",
        "patchSetId": 16
      },
      "lineNbr": 212,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-16T03:32:24Z",
      "side": 1,
      "message": "\u003e Seeing the scope of the changes in the patch, it seems we are missing on a design document.\n\nCan you unpack what you mean by this? Can you be more specific about what your scope concerns are?\n\nFrom my perspective, this change is just about introducing a new, more flexible API for implementing PLDM transport bindings, and nothing more.\n\nTo that end, it adds the new API and implements the existing transport - the MCTP demux daemon UNIX domain socket - in terms of the new API. Further, it reimplements the old API in terms of the new API so we\u0027re not maintaining two separate implementations of the MCTP demux daemon socket transport. That is the full scope of this change.\n\nThis scope is a subset of Naveen\u0027s design proposal that\u0027s been in review for over a year:\n\nhttps://gerrit.openbmc.org/c/openbmc/docs/+/47519\n\nBy introducing this new API we give ourselves the building blocks to implement the NC-SI/RBT PLDM transport - this just becomes yet another transport implementation that exposes a `struct pldm_transport`, which hooks into the generic portion of the new API provided in this patch. Further, the new API gives us the ability to implement the transition away from the MCTP demux daemon to the kernel\u0027s `AF_MCTP` sockets. libmctp is deprecated for use in OpenBMC, all future MCTP needs in OpenBMC must be met through `AF_MCTP` sockets.\n\nGiven we\u0027re introducing a new API it\u0027s worth considering what changes might occur in the future that could impact how the API is used. That said, I\u0027ve put effort into the proposal above to make sure that while it\u0027s forwards looking to other possibilities for instance ID management, the API continues to work for the current method as well. As such I\u0027m struggling to grasp the concern about scope and the prototype of `pldm_requester_send_msg()` above. Perhaps the concern is just the identification of the future possibility of changing the approach to instance ID management? That seems likely, so let me discuss that for a moment:\n\nThe current method of instance ID management is centralised in `pldmd` as you mentioned. `pldmd` uses this instance ID allocator for its own purposes when sending messages, but also exposes a DBus API. The DBus API enables multiple processes communicating via PLDM to collectively allocate unique instance IDs for their exchanges. `pldmd` is the central resource that controls the allocation.\n\nThere are problems with this: An application may request an instance ID, perform a message exchange with a device, but fail to return the instance ID to `pldmd`. It may fail to do this because of a logic error in the application that means that the instance ID is simply never released, or that the application crashes before having an opportunity to return the instance ID. A new instance of the process won\u0027t know that the prior process had allocated the ID and so at that point there is nothing that can be returned. There\u0027s a risk of an instance ID resource leak.\n\nAnother concern is that a PLDM endpoint might be unresponsive. Without further intervention, there\u0027s a risk that the instance ID pool might be exhausted by the lack of replies. To protect against such failure modes, PLDM specifies timeout and retry intervals that returns ID to the pool if a response does not arrive. `pldmd` implements these timers and releases the ID back to the pool without consulting the application to which it was allocated. The resource leak in the previous paragraph can be bounded by these timeouts.\n\nHowever, another way to exhaust the instance ID pool is by uncoordinated applications exchanging a large number of of PLDM messages in a short period of time. This problem is particularly bad for `pldmd` itself, which may get wedged by not having an instance ID available to send a request. `pldmd` reduces this risk by freeing instances IDs prior to timer expiry. Its approach does so without requiring interaction from the requesting application (some evidence of this is that the DBus API provides a `GetInstanceId` method, but does not provide a `PutInstanceId` method: https://github.com/openbmc/phosphor-dbus-interfaces/blob/d99cca374b57c65e770899fdf8b1ff381d580b3c/yaml/xyz/openbmc_project/PLDM/Requester.interface.yaml)\n\nThis mitigation is entirely built around an implementation detail of mctp-demux-daemon, which broadcasts a given MCTP response message to all clients connected via its UNIX domain socket. This means for a request sent by e.g. `openpower-occ-control`, the response will be seen by both `openpower-occ-control` and `pldmd`. `pldmd` snoops these responses to free instance IDs prior to timer expiry:\n\nhttps://github.com/openbmc/pldm/blob/d99cca374b57c65e770899fdf8b1ff381d580b3c/pldmd/pldmd.cpp#L139\n\nIt was never a promise of the mctp-demux-daemon socket ABI that `mctp-demux-daemon` would behave that way.\n\nReturning to an earlier point, `libmctp` for use in OpenBMC is deprecated. We need to use `AF_MCTP` sockets going forward.\n\n`AF_MCTP` sockets do not allow `pldmd` to snoop on traffic in the same fashion as `mctp-demux-daemon`:\n\n\u003e Like the send calls, sockets will only receive responses to requests they have sent (TO\u003d1) and may only respond (TO\u003d0) to requests they have received.\n\nhttps://github.com/openbmc/docs/blob/master/designs/mctp/mctp-kernel.md#recvfrom-recvmsg-recv--read-receive-an-mctp-message\n\nGiven all of these concerns, it\u0027s likely that at some point in the future we want to migrate instance ID management into the kernel where we do have global visibility of PLDM traffic. There\u0027s a precedent for this too: MCTP tags are fundamentally similar, and we can manage instance IDs using the same techniques. That said there\u0027s no concrete proposal on the table for this yet, but hopefully the discussion above provides enough context for why we need to think about the future with the new requester API.",
      "parentUuid": "ee25aec1_5655a990",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 212,
        "endChar": 18
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09963598_867ff01b",
        "filename": "include/libpldm/requester/pldm.h",
        "patchSetId": 16
      },
      "lineNbr": 212,
      "author": {
        "id": 1000005
      },
      "writtenOn": "2023-02-16T16:18:41Z",
      "side": 1,
      "message": "\u003e Can you unpack what you mean by this? Can you be more specific about what your scope concerns are?\n\nI thought libpldm was a userspace library and moving instance ID management to kernel came as a surprise. But I see that it is a future topic. Do we want to impact the libpldm APIs with the future items or make changes as we have more clarity?\n\n\u003e By introducing this new API we give ourselves the building blocks to implement the NC-SI/RBT PLDM transport - this just becomes yet another transport implementation that exposes a struct pldm_transport, which hooks into the generic portion of the new API provided in this patch. Further, the new API gives us the ability to implement the transition away from the MCTP demux daemon to the kernel\u0027s AF_MCTP sockets. libmctp is deprecated for use in OpenBMC, all future MCTP needs in OpenBMC must be met through AF_MCTP sockets.\n\nI am aligned with these goals, based on the earlier discussions.\n\nI am visualizing that with more adoption of standards (Redfish/PLDM/MCTP) from DMTF, there will be multiple PLDM apps implementing different PLDM types covering FRU management, BIOS, Monitoring \u0026 Control \u0026 firmware update areas. So pldmd(or a single app) being the arbitrator of instance ID and dealing it on D-Bus can be a cause of bottleneck. So, I like the idea of moving instance ID management to kernel. if there is an underlying assumption that all the PLDM apps share the same terminus as source (BMC is a single PLDM terminus).\n\nWe should also have a flexibility where PLDM apps could act as an independent PLDM terminus in which case instance ID management can be contained within app and need not be coordinated across apps. Also need clarity on instance ID expiry, PLDM request retry if we are going ahead with moving instance ID management to kernel.",
      "parentUuid": "90d4fd19_abd20891",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 212,
        "endChar": 18
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dda47661_ddc4cfb2",
        "filename": "include/libpldm/requester/pldm.h",
        "patchSetId": 16
      },
      "lineNbr": 212,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-16T22:51:21Z",
      "side": 1,
      "message": "\u003e Do we want to impact the libpldm APIs with the future items or make changes as we have more clarity?\n\nIn general we don\u0027t want to influence the public API for use-cases that aren\u0027t yet material because we don\u0027t want to introduce function prototypes or objects that doesn\u0027t actually work for that use-case.\n\nHowever, in this specific case, there\u0027s a fairly concrete understanding of what we might have to do to completely support `AF_MCTP`-based communication, and so I think it\u0027s reasonable that we try to accommodate that now to avoid breaking the API in the future. If we don\u0027t include the parameter now and then implement the in-kernel suggestion, then we already know we *will* have to break the API when we do. So I think the fore-thought here is justified. The insurance is the forward-looking behaviour can be met even with the current implementation, so there\u0027s no penalty for doing it.\n\nAs to whether the parameter is the right way to go about it, maybe we just return it instead? People have to inspect the return value for the failure code, but the only confusing bit about that is we\u0027re kinda introducing a derived type that\u0027s the union of `pldm_requester_rc_t` and `uint8_t`, and sorta have to just mash that into an `int`?\n\n\u003e I thought libpldm was a userspace library and moving instance ID management to kernel came as a surprise. \n\nWe need to be careful here because libpldm isn\u0027t just a hosted (userspace) library. We can\u0027t assume it will be running on OpenBMC, or even under Linux. It should be usable in freestanding (e.g. firmware, kernel) environments also.\n\n\u003e if there is an underlying assumption that all the PLDM apps share the same terminus as source (BMC is a single PLDM terminus).\n\nI don\u0027t think this is a limitation that exists (see below):\n\n\u003e We should also have a flexibility where PLDM apps could act as an independent PLDM terminus\n\nYep. I can\u0027t see this being a problem for in-kernel handling, given it already supports participating in e.g. multiple MCTP networks, using multiple MCTP EIDs in the same way that it supports multiple IP addresses.\n\n\u003e Also need clarity on instance ID expiry, PLDM request retry if we are going ahead with moving instance ID management to kernel.\n\nYep, this is something that needs to be written down and hashed out in a design document, for sure. I think given the implementation of e.g. TCP in the kernel there should be ways we can accommodate PLDM reliable delivery requirements.",
      "parentUuid": "09963598_867ff01b",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 212,
        "endChar": 18
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ddd5615_d84b2ed5",
        "filename": "include/libpldm/requester/pldm.h",
        "patchSetId": 16
      },
      "lineNbr": 212,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-16T23:51:46Z",
      "side": 1,
      "message": "Oh, as another consideration for the out-parameter approach, this makes the function prototype of `pldm_requester_send_msg()` align with the prototype of `pldm_requester_recv_msg()`",
      "parentUuid": "dda47661_ddc4cfb2",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 212,
        "endChar": 18
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e53c62c4_c9ab2c43",
        "filename": "include/libpldm/requester/pldm.h",
        "patchSetId": 16
      },
      "lineNbr": 212,
      "author": {
        "id": 1000005
      },
      "writtenOn": "2023-02-21T17:45:01Z",
      "side": 1,
      "message": "\u003eAs to whether the parameter is the right way to go about it, maybe we just return it instead? People have to inspect the return value for the failure code, but the only confusing bit about that is we\u0027re kinda introducing a derived type that\u0027s the union of pldm_requester_rc_t and uint8_t, and sorta have to just mash that into an int?\n\nThe current signature of the function looks better than mixing the rc and the generated instance id.",
      "parentUuid": "3ddd5615_d84b2ed5",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 212,
        "endChar": 18
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "50778d34_d159ba70",
        "filename": "include/libpldm/requester/pldm.h",
        "patchSetId": 16
      },
      "lineNbr": 212,
      "author": {
        "id": 1000224
      },
      "writtenOn": "2023-03-22T21:30:06Z",
      "side": 1,
      "message": "With the new approach we can get away from the instance id needing to be passed out here.",
      "parentUuid": "e53c62c4_c9ab2c43",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 212,
        "endChar": 18
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5d665b7a_9d3e4a9a",
        "filename": "include/libpldm/requester/pldm.h",
        "patchSetId": 16
      },
      "lineNbr": 247,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-14T05:19:47Z",
      "side": 1,
      "message": "Missing indent?",
      "range": {
        "startLine": 246,
        "startChar": 11,
        "endLine": 247,
        "endChar": 24
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e282681e_499441c6",
        "filename": "include/libpldm/requester/pldm.h",
        "patchSetId": 16
      },
      "lineNbr": 247,
      "author": {
        "id": 1000224
      },
      "writtenOn": "2023-02-14T07:36:56Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5d665b7a_9d3e4a9a",
      "range": {
        "startLine": 246,
        "startChar": 11,
        "endLine": 247,
        "endChar": 24
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c908aeb4_c3611147",
        "filename": "include/libpldm/requester/pldm.h",
        "patchSetId": 16
      },
      "lineNbr": 280,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-14T05:19:47Z",
      "side": 1,
      "message": "Missing indent?",
      "range": {
        "startLine": 279,
        "startChar": 11,
        "endLine": 280,
        "endChar": 74
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5d18e139_95ccb06b",
        "filename": "include/libpldm/requester/pldm.h",
        "patchSetId": 16
      },
      "lineNbr": 280,
      "author": {
        "id": 1000224
      },
      "writtenOn": "2023-02-14T07:36:56Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c908aeb4_c3611147",
      "range": {
        "startLine": 279,
        "startChar": 11,
        "endLine": 280,
        "endChar": 74
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc3b1b0c_59778c72",
        "filename": "src/requester/meson.build",
        "patchSetId": 16
      },
      "lineNbr": 3,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-14T05:19:47Z",
      "side": 1,
      "message": "Let\u0027s instead add a meson file in the transport directory and append `mctp-demux.c` there. Will need to add `subdir(\u0027transport\u0027)` to `src/meson.build`.",
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e5920d3a_9ba8a5ed",
        "filename": "src/requester/meson.build",
        "patchSetId": 16
      },
      "lineNbr": 3,
      "author": {
        "id": 1000224
      },
      "writtenOn": "2023-02-14T07:36:56Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cc3b1b0c_59778c72",
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32c74145_3d375316",
        "filename": "src/requester/pldm.c",
        "patchSetId": 16
      },
      "lineNbr": 72,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-14T05:19:47Z",
      "side": 1,
      "message": "Given we\u0027re no-longer even looking at `.revents` in `pldm_requester_poll()` I think we can drop this, they\u0027re dead stores and are meaningless.",
      "range": {
        "startLine": 68,
        "startChar": 1,
        "endLine": 72,
        "endChar": 2
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "82330a4b_2e684a8d",
        "filename": "src/requester/pldm.c",
        "patchSetId": 16
      },
      "lineNbr": 72,
      "author": {
        "id": 1000224
      },
      "writtenOn": "2023-02-14T07:36:56Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "32c74145_3d375316",
      "range": {
        "startLine": 68,
        "startChar": 1,
        "endLine": 72,
        "endChar": 2
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e597ee7f_537f9ae6",
        "filename": "src/requester/pldm.c",
        "patchSetId": 16
      },
      "lineNbr": 76,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-14T05:19:47Z",
      "side": 1,
      "message": "nit: Add another newline here to help with visual separation to the function prototype below.",
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fd5eb422_6f75a753",
        "filename": "src/requester/pldm.c",
        "patchSetId": 16
      },
      "lineNbr": 76,
      "author": {
        "id": 1000224
      },
      "writtenOn": "2023-02-14T07:36:56Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e597ee7f_537f9ae6",
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a2e3dad_56814c70",
        "filename": "src/transport/container_of.h",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-14T05:19:47Z",
      "side": 1,
      "message": "Do we squash the prior patch into this one? If not we should fix this move there rather than in this patch.\n\nIMO this is trivial enough to just squash in.",
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8b172785_a8ba8b28",
        "filename": "src/transport/container_of.h",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 1000224
      },
      "writtenOn": "2023-02-14T07:36:56Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "4a2e3dad_56814c70",
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2103168b_b831e3d5",
        "filename": "src/transport/mctp-demux.c",
        "patchSetId": 16
      },
      "lineNbr": 191,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-14T05:41:23Z",
      "side": 1,
      "message": "void",
      "range": {
        "startLine": 191,
        "startChar": 64,
        "endLine": 191,
        "endChar": 66
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7bd6c7fc_0c9cdc92",
        "filename": "src/transport/mctp-demux.c",
        "patchSetId": 16
      },
      "lineNbr": 191,
      "author": {
        "id": 1000224
      },
      "writtenOn": "2023-02-14T07:36:56Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "2103168b_b831e3d5",
      "range": {
        "startLine": 191,
        "startChar": 64,
        "endLine": 191,
        "endChar": 66
      },
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d524b5f0_962fdbe1",
        "filename": "src/transport/transport_internal.h",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-14T05:19:47Z",
      "side": 1,
      "message": "How about we place this at `src/transport.h`? Any header in `src/` is internal by definition and so I think we can drop that part of the path and include guard symbol name.",
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2783621c_0584d6e4",
        "filename": "src/transport/transport_internal.h",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 1000224
      },
      "writtenOn": "2023-02-14T07:36:56Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d524b5f0_962fdbe1",
      "revId": "815f1bb23e28d78cef3efe77a0ba7a1343896652",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}