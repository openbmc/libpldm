{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "52c2d67a_c5b08fbd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 36
      },
      "lineNbr": 0,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2026-01-20T22:33:11Z",
      "side": 1,
      "message": "It seems like this would be quite a bit easier to read and reason about if we came up with a different mechanism for UT than compilation-switch-hidden friend declarations. A couple of options come to mind, in order of my personal preference:\n\n1. Make the public interface testable. Who are we protecting with the current implementation? Are the interfaces that easy to use incorrectly? Should we just be providing safer interfaces if so? What is the worst that will happen if this interfaces are used incorrectly?\n\n2. Just use \"seam mocking\" instead, i.e. make each layer\u0027s public interface useable for each classes responsibility but obfuscate the inner layers from the end user\n\n3. Use compile time dependency injection for your test fixtures. I don\u0027t like this as much personally, as it complicates the code for the sake of UT, i.e. now I need to understand a bunch of CRTP-esque declarations just to reason about my pldm parser.\n\n\nI understand that UT can often be tricky in C++, but it seems odd to me to add this much compile time switching for the non-production path, almost all of the time, I want to read the production path to figure out whats going on.\n\nThat said, thanks for this change, I\u0027ve looked at doing this elsewhere and written something similar to support it, having it in a reusable place like libpldm will be great.",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d00deff1_e1e05dc3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 36
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2026-01-22T07:42:42Z",
      "side": 1,
      "message": "\u003e Make the public interface testable. Who are we protecting with the current implementation?\n\nIt\u0027s a parser so no one besides the implementation should be able to construct these objects.\n\n\u003e Just use \"seam mocking\" instead, i.e. make each layer\u0027s public interface\n useable for each classes responsibility but obfuscate the inner layers \nfrom the end user\n\nI don\u0027t understand how that would look like. Would you like to fork my patch? Maybe it will be easier to understand from the code itself.\n\n\u003e I understand that UT can often be tricky in C++, but it seems odd to me \nto add this much compile time switching for the non-production path, \nalmost all of the time, I want to read the production path to figure out\n whats going on.\n\nIf i were to use a library like PackageParser, i would look at examples / tests first and if those are fine then no need to dig into implementation details.\n\n\u003e I\u0027ve looked at doing this elsewhere and written something similar to \nsupport it, having it in a reusable place like libpldm will be great.\n\nWell then it\u0027s  \u003e\u003d 3 places which need the PackageParser. There\u0027s `pldm`, `phosphor-bmc-code-mgmt`, and your use-case üòä",
      "parentUuid": "52c2d67a_c5b08fbd",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c10d4c8a_85fc3342",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 36
      },
      "lineNbr": 0,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2026-01-22T17:52:58Z",
      "side": 1,
      "message": "my larger point is that we\u0027re probably making more problems than we\u0027re solving with somewhat draconian public/private/friend disctinctions.\n\nWhats the worst that happens if someone calls the Package constructor? what damage could they actually do with it? It doesn\u0027t seem like they\u0027ll be able to influence the parsing in any way, they\u0027ll just have a Package object that they can\u0027t move or copy.\n\nWhy shouldn\u0027t someone be able to construct a DescriptorData from a vector of data? They\u0027ll just have a data type they can\u0027t do much with, and sure its maybe its wasteful, but they won\u0027t really be able to do anything with it.\n\nWe\u0027re imposing restrictions that are making it harder than necessary to test this, and then we\u0027re making the code more complicated yet to facilitate said testing.",
      "parentUuid": "d00deff1_e1e05dc3",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2fd14039_19ba7e6d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 36
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2026-01-23T02:31:52Z",
      "side": 1,
      "message": "\u003e Why shouldn\u0027t someone be able to construct a DescriptorData from a vector of data? They\u0027ll just have a data type they can\u0027t do much \nwith, and sure its maybe its wasteful, but they won\u0027t really be able to \ndo anything with it.\n\nIt\u0027s an extra function in the ABI dump and possibly a burden to the maintainer.\n\nEvery spec change might involve additional struct members which then require an additional constructor to create it, bloating the API and ABI surface.\n\nI\u0027m happy to consider exposing the constructors to facilitate an actual use-case which cannot otherwise be done.\n\nI would also like to hear @andrew@codeconstruct.com.au thoughts on the subject before exposing the constructors.\n\nSince there was feedback previously about the d-pointer solution that it exposes so many functions/symbols. A constructor is an extra symbol so as per that feedback i should avoid it.\n\n\u003e We\u0027re imposing restrictions that are making it harder than necessary to test this, and then we\u0027re making the code more complicated \nyet to facilitate said testing.\n\nWe have so many constraints from various directions, from C++ language features which don\u0027t work together (looking at you, `make_unique` and `friend`!), ABI stability, need to account for spec changes, being able to test things, needing growable structures, exposing only the minimum amount of symbols, ...\n\nthat it is difficult for me to see how it could be simplified.\n\nI\u0027m following the design and ideas from @andrew@codeconstruct.com.au so for major changes i would like him to provide the feedback. \n\nOtherwise we might \u0027improve it\u0027 from our perspective but then later have to undo all that again if it has become worse from his perspective.",
      "parentUuid": "c10d4c8a_85fc3342",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "51f3194b_a7f2dab9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 36
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2026-01-29T05:30:04Z",
      "side": 1,
      "message": "\u003e It\u0027s an extra function in the ABI dump and possibly a burden to the maintainer.\n\u003e\n\n\u003e Every spec change might involve additional struct members which then require an additional constructor to create it, bloating the API and ABI surface.\n\nIf we\u0027re exposing the members directly (in a `struct` sense) I think there\u0027s merit to avoiding attempts to provide constructors that take values for every member, and instead only providing the default constructor (and the usual copy/move constructors as required)? If people want to construct an empty package then that\u0027s their business. The library APIs however will construct it and then populate it, and only ever return the populated object (or an error).\n\n\u003e We have so many constraints from various directions, from C++ language features which don\u0027t work together (looking at you, make_unique and friend!), ABI stability, need to account for spec changes, being able to test things, needing growable structures, exposing only the minimum amount of symbols, ...\n\n\nRight, there\u0027s a bit of tension here between these concerns.\n\nBroadly, what I\u0027m after is that we account for spec changes adding new capabilities in the design (this has already happened several times), in such a way that the additions aren\u0027t often a breaking change, or require branched code paths in the callers, as best we can. Growable structures naturally play into this as a solution, but that\u0027s one approach to achieving the high-level desire, not a requirement in its own right. Symbol minimalism can only go so far, we can\u0027t avoid adding symbols that are essential to the problem, but we can work to eliminate symbols that are accidental complexity (in the No Silver Bullet sense) by decisions in the implementation\n\nThat all relates to ABI stability, however, my concern there isn\u0027t to prevent the unpreventable with changes in e.g. exposed `std::` components, rather, just that we think about things and do the best we can to design something that _shouldn\u0027t_ break _for the bits we\u0027ve defined_. `abi-compliance-checker` failing isn\u0027t an unquestionable gate that prevents submission, it\u0027s an input for consideration as to whether the patch is appropriate.\n\nI\u0027ll probably have further thoughts here but that\u0027s it for the moment.",
      "parentUuid": "2fd14039_19ba7e6d",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c922e5c_4d7f5c06",
        "filename": "bindings/cpp/firmware_update.cpp",
        "patchSetId": 36
      },
      "lineNbr": 41,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2026-01-20T22:33:11Z",
      "side": 1,
      "message": "nit, std::make_unique doesn\u0027t work here? it would be slightly less verbose. Also below on line 76.",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "faf60663_5bd29780",
        "filename": "bindings/cpp/firmware_update.cpp",
        "patchSetId": 36
      },
      "lineNbr": 41,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2026-01-22T07:42:42Z",
      "side": 1,
      "message": "It does not work since that template is not our friend.\n\nSo it cannot call the private constructor.",
      "parentUuid": "9c922e5c_4d7f5c06",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d019ca1_c94d5cb7",
        "filename": "bindings/cpp/firmware_update.cpp",
        "patchSetId": 36
      },
      "lineNbr": 103,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2026-01-20T22:33:11Z",
      "side": 1,
      "message": "nit: \u003ddefault doesn\u0027t work here? is this an ABI stability concern?",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "33637b7f_27cf135b",
        "filename": "bindings/cpp/firmware_update.cpp",
        "patchSetId": 36
      },
      "lineNbr": 103,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2026-01-22T07:42:42Z",
      "side": 1,
      "message": "Changed it to `\u003d default;`. I don\u0027t think it will make a difference here since it\u0027s part of the cpp.",
      "parentUuid": "1d019ca1_c94d5cb7",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "21082e5f_dd2ad34b",
        "filename": "include/libpldm/bindings/cpp/firmware_update.hpp",
        "patchSetId": 36
      },
      "lineNbr": 26,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2026-01-20T22:33:11Z",
      "side": 1,
      "message": "do we want explicit here?",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aefefa83_2f3f0f41",
        "filename": "include/libpldm/bindings/cpp/firmware_update.hpp",
        "patchSetId": 36
      },
      "lineNbr": 26,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2026-01-22T07:42:42Z",
      "side": 1,
      "message": "probably. fixed it üëç",
      "parentUuid": "21082e5f_dd2ad34b",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e956fdb_6d7b5cd7",
        "filename": "include/libpldm/bindings/cpp/firmware_update.hpp",
        "patchSetId": 36
      },
      "lineNbr": 39,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2026-01-20T22:33:11Z",
      "side": 1,
      "message": "this seems like a very odd set of constructiors? was the move ctor meant to be deleted? I\u0027m having a difficult time imagining a case where I\u0027d want to move construct but not move assign an object.",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e632f820_81f3dd32",
        "filename": "include/libpldm/bindings/cpp/firmware_update.hpp",
        "patchSetId": 36
      },
      "lineNbr": 39,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2026-01-22T07:42:42Z",
      "side": 1,
      "message": "yep, my mistake. I should have simply inherited from `NonCopyableNonMoveable` like the other classes do. Fixed it.",
      "parentUuid": "4e956fdb_6d7b5cd7",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82bc7868_a41a81e1",
        "filename": "include/libpldm/bindings/cpp/firmware_update.hpp",
        "patchSetId": 36
      },
      "lineNbr": 53,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2026-01-20T22:33:11Z",
      "side": 1,
      "message": "This seems like it would be a good candidate for a free function? Whats the purpose of this class? I cant construct it, except by move construction, it seems I can only call this static method.",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b51d2c7a_91f2cb0b",
        "filename": "include/libpldm/bindings/cpp/firmware_update.hpp",
        "patchSetId": 36
      },
      "lineNbr": 53,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2026-01-22T07:42:42Z",
      "side": 1,
      "message": "The helper and parse functions need to construct a few objects. So `PackageParser` is a friend of these classes to facilitate that.\n\nI did not want to copy-paste these 2 function signatures into the friend declarations of the classes they construct, since it would be verbose and repetitive.\n\nAnd we cannot make an entire namespace a friend, right? So i did not see a way to solve it without a class.\n\n\nI\u0027m tentatively closing this comment but very much open to other solutions here.",
      "parentUuid": "82bc7868_a41a81e1",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "45d5cd4f_15359f2a",
        "filename": "include/libpldm/bindings/cpp/types.hpp",
        "patchSetId": 36
      },
      "lineNbr": 79,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2026-01-20T22:33:11Z",
      "side": 1,
      "message": "Do we have any data to show that we can\u0027t reasonably just use the checked access members as the public interface?",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1eff2181_914d899e",
        "filename": "include/libpldm/bindings/cpp/types.hpp",
        "patchSetId": 36
      },
      "lineNbr": 79,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2026-01-22T07:42:42Z",
      "side": 1,
      "message": "It worked out to make the unchecked access members private to this class.\n\nThanks for this fix üëç",
      "parentUuid": "45d5cd4f_15359f2a",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0173a1c_45cdf7f7",
        "filename": "include/libpldm/bindings/cpp/types.hpp",
        "patchSetId": 36
      },
      "lineNbr": 201,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2026-01-20T22:33:11Z",
      "side": 1,
      "message": "its relatively difficult to read this with all of these ifdefs littered about. Can we come up with a way to consolidate these? I have a feeling that some compile time DI would probably end up a bit cleaner.",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c4cb3a17_a3e3af56",
        "filename": "include/libpldm/bindings/cpp/types.hpp",
        "patchSetId": 36
      },
      "lineNbr": 201,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2026-01-22T07:42:42Z",
      "side": 1,
      "message": "yep, it\u0027s not looking nice ... compacted those to only one `#ifdef` per class for now üòä\n\n\u003e I have a feeling that some compile time DI would probably end up a bit cleaner.\n\nCan you go into detail here?\n\nI would also prefer a solution without `#ifdef`.",
      "parentUuid": "d0173a1c_45cdf7f7",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d87f58f_4797124c",
        "filename": "include/libpldm/bindings/cpp/types.hpp",
        "patchSetId": 36
      },
      "lineNbr": 201,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2026-01-23T02:31:52Z",
      "side": 1,
      "message": "Is it sufficient to have one per class, how can i simplify further?",
      "parentUuid": "c4cb3a17_a3e3af56",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57bd5b63_166fbc04",
        "filename": "include/libpldm/bindings/cpp/types.hpp",
        "patchSetId": 36
      },
      "lineNbr": 201,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2026-01-29T05:30:04Z",
      "side": 1,
      "message": "Like, this is a further hack, but at least a tidier one - can we fix up the definition of `LIBPLDM_ABI_TESTING` in the build system to incorporate `LIBPLDM_GTEST_FRIENDS` as an input to its definition rather than `#ifdef` it away here?\n\nThat said, I\u0027d much rather a design where we don\u0027t require this type of trickery at all.",
      "parentUuid": "6d87f58f_4797124c",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5265b80_44234209",
        "filename": "include/libpldm/bindings/cpp/types.hpp",
        "patchSetId": 36
      },
      "lineNbr": 201,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2026-02-02T07:36:00Z",
      "side": 1,
      "message": "\u003e can we fix up the definition of LIBPLDM_ABI_TESTING\n\n` \u0027__attribute__((visibility(\"default\")))\u0027  ` and things like that cannot help much with cleaning things up for things which are not symbols.\n\nWe would still require the conditional compilation and would complicate things further by spreading `LIBPLDM_GTEST_FRIENDS` to other places.\n\n\n\n\u003e That said, I\u0027d much rather a design where we don\u0027t require this type of trickery at all.\n\nIf testcases cannot construct our classes here then we cannot use a direct comparison and have to supplement external comparison functions and extra classes to compare with. Also then our comparison functions cannot be tested well since we cannot define the expected result.\n\nSo the testcases need to be friends with our class to call the private constructor.\n\nI\u0027m open to any ideas at this point, but comparing this to `stdexec` or `dbus-sensors` i find it to be plenty readable. \n\nFor most users the data members and operator overloads should be most interesting and those are clearly visible.",
      "parentUuid": "57bd5b63_166fbc04",
      "revId": "cf5ebccc54fa87374ce330e488f474ca587503e2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}