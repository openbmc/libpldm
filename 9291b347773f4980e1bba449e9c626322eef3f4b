{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "3bb868a5_e7e9a60c",
        "filename": "include/libpldm/base.h",
        "patchSetId": 11
      },
      "lineNbr": 363,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-03-18T00:27:33Z",
      "side": 1,
      "message": "This shouldn\u0027t be a pointer, rather a proper `struct variable field` object. Just populate the `ptr` member with the pointer into the message buffer, and then populate the `length` member appropriately.",
      "revId": "9291b347773f4980e1bba449e9c626322eef3f4b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6a3339c_b5eeb2c8",
        "filename": "include/libpldm/base.h",
        "patchSetId": 11
      },
      "lineNbr": 363,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-03-18T03:09:36Z",
      "side": 1,
      "message": "Acknowledged. Please help review my edit. At first I removed the `uint32_t data_length;` field to avoid duplication with the `length` field in the variable_field struct. But `pldm_msgbuf_extract` does not work with `size_t` so it needs casting and breaks the macro with `error: lvalue required as unary ‘\u0026’ operand`, which led me to directly using `pldm__msgbuf_extract_uint32`. I think this is not good, so now I define a local uint32_t var to hold the data length from extraction and assign it back to `length` for use. Both ways seem to make the function be aware of the data type of data length (an element of the struct), I don\u0027t know if I should put data_length back to the struct.",
      "parentUuid": "3bb868a5_e7e9a60c",
      "revId": "9291b347773f4980e1bba449e9c626322eef3f4b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "98bcc6d2_b38dcb29",
        "filename": "include/libpldm/base.h",
        "patchSetId": 11
      },
      "lineNbr": 363,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-03-18T04:13:23Z",
      "side": 1,
      "message": "Are you interested in working on adding e.g. a `pldm_msgbuf_extract_uint32_size()` API? I was also considering that recently after hitting similar limitations with the existing msgbuf APIs. I think that would make the code more ergonomic.",
      "parentUuid": "c6a3339c_b5eeb2c8",
      "revId": "9291b347773f4980e1bba449e9c626322eef3f4b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6442c4e2_ba3e56b9",
        "filename": "include/libpldm/base.h",
        "patchSetId": 11
      },
      "lineNbr": 363,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-03-18T06:05:22Z",
      "side": 1,
      "message": "\u003e #define pldm_msgbuf_extract_uint32_size(ctx, dst)                                   \\\n\tpldm__msgbuf_extract_uint32(ctx, (void *)\u0026(dst))\n\t\nDo you mean the above? I think it still requires the encode/decode API to know beforehand about the type of an element in the struct, which can possibly be changed after spec update.",
      "parentUuid": "98bcc6d2_b38dcb29",
      "revId": "9291b347773f4980e1bba449e9c626322eef3f4b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}