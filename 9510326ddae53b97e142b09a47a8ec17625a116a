{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "7d4bb417_8ecdcce0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-13T03:30:52Z",
      "side": 1,
      "message": "Hi Gilbert,\n\nI think the buffer handling is going to cause us headaches, but at least explicit is better than `__attribute__((packed))` leaking through the ABI and abusing it to do `memcpy()` in the implementation.\n\nI\u0027ve made a suggestion on value extraction from the buffers. Let me know what you think.",
      "revId": "9510326ddae53b97e142b09a47a8ec17625a116a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b17e91d6_3776d165",
        "filename": "src/platform.c",
        "patchSetId": 6
      },
      "lineNbr": 1255,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-13T03:30:52Z",
      "side": 1,
      "message": "Okay, explicit here is better. I think you\u0027ll agree it\u0027s a bit tedious though, and I wonder if we can make our lives easier by adding a little API to help out? We could encode the endian handling as well as a buffer cursor in it, for example:\n\n```\nstruct pldm_buf {\n    unsigned char *cursor;\n    size_t remaining;\n};\n\nint pldm_buf_init(struct pldm_buf *ctx, void *buf, size_t len)\n{\n    uintptr_t end;\n    \n    if (!buf) {\n        return PLDM_ERROR_INVALID_DATA;\n    }\n    \n    if (!len) {\n        return PLDM_ERROR_INVALID_LENGTH;\n    }\n    \n    end \u003d (uintptr_t)buf + len;\n    if (end \u0026\u0026 end \u003c (uintptr_t)buf) {\n        return PLDM_ERROR_INVALID_LENGTH;\n    }\n    \n    ctx-\u003ecursor \u003d buf;\n    ctx-\u003eremaining \u003d len;\n\n    return PLDM_SUCCESS;\n}\n\nint pldm_buf_destroy(struct pldm_buf *ctx)\n{\n    ctx-\u003ebuf;\n    ctx-\u003eremaining \u003d 0;\n}\n\nint pldm_buf_extract_uint8(struct pldm_buf *ctx, uint8_t *dst)\n{\n    if (!ctx-\u003eremaining) {\n        return PLDM_ERROR_INVALID_LENGTH;\n    }\n    \n    *dst \u003d ((uint8_t *)ctx)-\u003ecursor);\n    ctx-\u003ecursor++;\n    ctx-\u003eremaining--;\n    \n    return PLDM_SUCCESS;\n}\n\nint pldm_buf_extract_uint16(struct pldm_buf *ctx, uint16_t *dst)\n{\n    uint16_t ldst;\n\n    if (!ctx-\u003eremaining) {\n        return PLDM_ERROR_INVALID_LENGTH;\n    }\n    \n    if (ctx-\u003eremaining \u003c sizeof(*dst)) {\n        return PLDM_ERROR_INVALID_LENGTH;\n    }\n    \n    // Use memcpy() to have the compiler deal with any alignment\n    // issues on the target architecture\n    memcpy(\u0026ldst, ctx-\u003ecursor, sizeof(*dst));\n    // Only assign the target value once it\u0027s correctly decoded\n    *dst \u003d le16toh(ldst);\n    ctx-\u003ecursor +\u003d sizeof(*dst);\n    ctx-\u003eremaining -\u003d sizeof(*dst);\n    \n    return 0;\n}\n\n...\n```\n\netc. Fill out the rest of the extractors as required in accordance with the types in Table 1 - PLDM Data Types from DSP0240 v1.0.0. This keeps it safe wrt alignment, endianness and overflows.\n\nThen, all this below turns into:\n\n```\n    struct pldm_buf _buf, *buf \u003d \u0026_buf;\n    int rc;\n    \n    // With this check we can avoid testing the return values on\n    // the extractors below as we know we have enough buffer to\n    // satisfy all the reads.\n    if (pdr_data_length \u003c expectedPDRSize) {\n        return PLDM_ERROR_INVALID_LENGTH;\n    }\n\n    if ((rc \u003d pldm_buf_init(buf, pdr_data, pdr_data_length) \u003c 0) {\n        return rc;\n    }\n    \n    pldm_buf_extract_uint8(buf, \u0026pdr_value-\u003ehdr.version);\n    pldm_buf_extract_uint8(buf, \u0026pdr_value-\u003ehdr.type);\n    pldm_buf_extract_uint16(buf, \u0026pdr_value-\u003ehdr.record_change_num);\n    pldm_buf_extract_uint16(buf, \u0026pdr_value-\u003ehdr.length);\n    ...\n    pldm_buf_destroy(buf);\n```\n\netc.\n\nThoughts?",
      "revId": "9510326ddae53b97e142b09a47a8ec17625a116a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "444dd16b_213a52b2",
        "filename": "src/platform.c",
        "patchSetId": 6
      },
      "lineNbr": 1255,
      "author": {
        "id": 1000957
      },
      "writtenOn": "2023-02-13T05:29:20Z",
      "side": 1,
      "message": "It is good to have extractor. It improves code readability.\nSince the PDR length is unknown till the fields of sensor_data_size and range_field_format are decoded, I think new helper function, pldm_buf_resize(struct pldm_buf* ctx, size_t size), is needed to resize the pldm_buf when sensor_data_size and range_field_format field is decoded.\n\n    \n    struct pldm_buf {\n        unsigned char *cursor;\n        size_t remaining;\n        size_t size;\n    };\n\n    pldm_buf_resize(struct pldm_buf* ctx, size_t size)\n    {\n        // ensure that cursor is in range of new buf size\n        if ( size \u003c (ctx-\u003esize - ctx-\u003eremining) ) {\n            return PLDM_ERROR_INVALD_LENGTH;\n        }\n    \n        if (ctx-\u003esize \u003e size) {\n            ctx-\u003eremining -\u003d (ctx-\u003esize - size);\n        }\n        else {\n            ctx-\u003eremining +\u003d (size - ctx-\u003esize);\n        }\n        ctx-\u003esize \u003d size;\n\n        return 0;\n    }",
      "parentUuid": "b17e91d6_3776d165",
      "revId": "9510326ddae53b97e142b09a47a8ec17625a116a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ccaaa25b_3118f964",
        "filename": "src/platform.c",
        "patchSetId": 6
      },
      "lineNbr": 1255,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-02-13T05:42:33Z",
      "side": 1,
      "message": "Yeah, that sounds good!",
      "parentUuid": "444dd16b_213a52b2",
      "revId": "9510326ddae53b97e142b09a47a8ec17625a116a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}